# खोजना

<!-- toc -->

Anki की ब्राउज़ स्क्रीन और फ़िल्टर किए गए डेक सुविधा विशिष्ट कार्ड/नोट्स खोजने के लिए एक सामान्य विधि का उपयोग करती है। इस विधि का उपयोग FSRS अनुकूलन के दायरे को समायोजित करने के लिए भी किया जा सकता है।

## सरल खोजें

जब आप खोज बॉक्स में कुछ पाठ टाइप करते हैं, तो Anki मेल खाने वाले नोट्स ढूंढता है और उनके कार्ड प्रदर्शित करता है। Anki नोट्स के सभी क्षेत्रों में खोज करता है, लेकिन टैग के लिए खोज नहीं करता है (टैग खोजने के लिए [इस अनुभाग में बाद में](#tags-decks-cards-and-notes) देखें)। कुछ उदाहरण:

`dog`
"dog" के लिए खोजता है - "doggy" और "underdog" जैसे शब्दों से भी मेल खाएगा।

`dog cat`
उन नोट्स को ढूंढता है जिनमें "dog" और "cat" दोनों हैं, जैसे "raining cats and dogs"।

`dog or cat`
"dog" या "cat" वाले नोट्स ढूंढता है।

`dog (cat or mouse)`
"dog" और "cat", या "dog" और "mouse" वाले नोट्स ढूंढता है।

`-cat`
"cat" के बिना नोट्स ढूंढता है।

`-cat -mouse`
न तो "cat" और न ही "mouse" वाले नोट्स ढूंढता है।

`-(cat or mouse)`
उपरोक्त के समान।

`"a dog"`
उनमें "a dog" वर्णों के सटीक अनुक्रम वाले नोट्स ढूंढता है, जैसे "atta dog", लेकिन "dog a" या "adog" नहीं।

`-"a dog"`
उनमें "a dog" वर्णों के सटीक अनुक्रम के बिना नोट्स ढूंढता है।

`d_g`
d, <एक वर्ण>, g, जैसे dog, dig, dug, और इसी तरह के नोट्स ढूंढता है।

`d*g`
d, <शून्य या अधिक वर्ण>, g, जैसे dg, dog, dung, आदि वाले नोट्स ढूंढता है।

`w:dog`
वर्णों के अनुक्रम के बजाय "dog" शब्द की खोज करता है - "dog" से मेल खाएगा, लेकिन "doggy" या "underdog" से नहीं। Anki 2.1.24+, AnkiMobile 2.1.61+, या AnkiDroid 2.17+ की आवश्यकता है। ध्यान दें कि स्वरूपण परिवर्तनों को शब्द सीमाओं के रूप में व्याख्या किया जा सकता है, उदा। `w:exam` की खोज **exam**ple से मेल खाएगी, क्योंकि उदाहरण का "exam" भाग बोल्ड प्रारूप में है।

`w:dog*`
"dog" और "doggy" से मेल खाएगा, लेकिन "underdog" से नहीं।

`w:*dog`
"dog" और "underdog" से मेल खाएगा, लेकिन "doggy" से नहीं।

उपरोक्त से ध्यान देने योग्य बातें:

- खोज शब्द रिक्त स्थान द्वारा अलग किए जाते हैं।

- जब कई खोज शब्द प्रदान किए जाते हैं, तो Anki उन नोट्स की तलाश करता है जो सभी शर्तों से मेल खाते हैं - प्रत्येक पद के बीच एक अंतर्निहित `and` डाला जाता है। Anki 2.1.24+, AnkiMobile 2.0.60+, और AnkiDroid 2.17+ पर आप चाहें तो स्पष्ट हो सकते हैं (`dog and cat` `dog cat` के समान है), लेकिन पुराने Anki संस्करण `and` को खोजने के लिए सिर्फ एक और शब्द के रूप में मानेंगे।

- यदि आपको केवल एक पद के मिलान की आवश्यकता है तो आप `or` का उपयोग कर सकते हैं।

- आप उन नोट्स को खोजने के लिए एक पद के पहले एक ऋण चिह्न (`-`) लगा सकते हैं जो पद से मेल नहीं खाते हैं।

- आप खोज शब्दों को कोष्ठक में रखकर समूहित कर सकते हैं, जैसा कि `dog (cat or mouse)` उदाहरण में है। यह OR और AND खोजों को मिलाते समय महत्वपूर्ण हो जाता है - उदाहरण में, कोष्ठक के साथ, यह या तो "dog cat" या "dog mouse" से मेल खाता है, जबकि उनके बिना यह या तो "dog and cat" या "mouse" से मेल खाता है।

- Anki केवल आपके द्वारा कॉन्फ़िगर किए गए [सॉर्ट फ़ील्ड](editing.md#customizing-fields) में स्वरूपण के भीतर खोज करने में सक्षम है। उदाहरण के लिए, यदि आप अपने किसी फ़ील्ड में "**exa**mple" जोड़ते हैं, जिसमें "exa" भाग बोल्ड में है, तो `example` की खोज करते समय यह तब तक मेल नहीं खाएगा जब तक कि वह फ़ील्ड सॉर्ट फ़ील्ड न हो। यदि कोई शब्द स्वरूपित नहीं है, या शब्द के बीच में स्वरूपण नहीं बदलता है, तो Anki इसे किसी भी फ़ील्ड में ढूंढ पाएगा।

- मानक खोजें लैटिन वर्णों के लिए केस-असंवेदनशील होती हैं - a-z A-Z से मेल खाएगा, और इसके विपरीत। साइरिलिक जैसे अन्य वर्ण एक मानक खोज में केस-संवेदी होते हैं, लेकिन शब्द सीमा या नियमित अभिव्यक्ति (`w:`, `re:`) पर खोज करके केस-असंवेदनशील बनाया जा सकता है।

## एक फ़ील्ड तक सीमित करना

आप Anki से यह भी पूछ सकते हैं कि क्या कोई विशेष फ़ील्ड कुछ पाठ содержит है। पिछले खोज उदाहरणों के विपरीत, फ़ील्ड में खोजना डिफ़ॉल्ट रूप से एक सटीक मिलान की आवश्यकता है।

`front:dog`
बिल्कुल "dog" के फ्रंट फ़ील्ड वाले नोट्स ढूंढता है। "a dog" कहने वाला एक फ़ील्ड मेल नहीं खाएगा।

`"animal front:a dog"`
उन नोट्स को ढूंढता है जहां "एनिमल फ्रंट" फ़ील्ड बिल्कुल "a dog" है। दोहरे उद्धरण अनिवार्य हैं: [इस अनुभाग में बाद में](#matching-special-characters) देखें।

`front:*dog*`
उन नोट्स को ढूंढता है जहां फ्रंट फ़ील्ड में कहीं dog है।

`front:`
खाली फ्रंट फ़ील्ड वाले नोट्स ढूंढता है।

`front:_*
`
गैर-खाली फ्रंट फ़ील्ड वाले नोट्स ढूंढता है।

`front:*`
एक फ्रंट फ़ील्ड वाले नोट्स ढूंढता है, खाली या नहीं।

`fr*:text`
"fr" से शुरू होने वाले एक फ़ील्ड में नोट्स ढूंढता है। Anki 2.1.24+, AnkiMobile 2.1.60+, या AnkiDroid 2.17+ की आवश्यकता है।

## टैग, डेक, कार्ड और नोट्स

`tag:animal`
"animal" टैग वाले नोट्स, या "animal::mammal" जैसे सबटैग ढूंढता है।

`tag:none`
बिना टैग वाले नोट्स ढूंढता है।

`tag:ani*`
"ani" से शुरू होने वाले टैग वाले नोट्स ढूंढता है।

`deck:french`
"French" नामक एक शीर्ष-स्तरीय डेक में कार्ड, या "French::Words" जैसे इसके सबडेक ढूंढता है। यह उस नाम के सबडेक से मेल नहीं खाएगा, जैसे "Languages::French"।

`deck:french::words`
"French::Words" सबडेक में कार्ड ढूंढता है।

`deck:french -deck:french::*`
"French" में कार्ड ढूंढता है, लेकिन इसके सबडेक नहीं।

`deck:"french words"`
जब डेक नाम में एक स्थान होता है तो खोजना।

`"deck:french words"`
पहले जैसा ही।

`deck:filtered`
केवल फ़िल्टर किए गए डेक।

`-deck:filtered`
केवल सामान्य डेक।

`preset:"Default"`
"Default" डेक विकल्प प्रीसेट का उपयोग करने वाले सभी डेक में कार्ड। Anki 23.10+, AnkiMobile 23.10+ या AnkiDroid 2.17+ की आवश्यकता है।

`card:forward`
"Forward" नामक कार्ड प्रकार द्वारा बनाए गए कार्ड ढूंढता है।

`card:1`
कार्ड प्रकार संख्या के अनुसार कार्ड खोजता है, उदा। एक नोट के लिए दूसरा क्लोज विलोपन खोजने के लिए, आप `card:2` का उपयोग करेंगे

`note:basic`
"Basic" नामक नोट प्रकार के साथ बनाए गए कार्ड खोजता है।

## लहजे/संयोजन वर्णों को अनदेखा करना

Anki 2.1.24+, AnkiMobile 2.0.60+ या AnkiDroid 2.17+ की आवश्यकता है।

आप Anki को संयोजन वर्णों को अनदेखा करने के लिए `nc:` (nc का अर्थ "कोई संयोजन नहीं") का उपयोग कर सकते हैं। उदाहरण के लिए:

`nc:uber`
"uber", "über", "Über" आदि वाले नोट्स से मेल खाता है।

`nc:は`
"は", "ば", और "ぱ" से मेल खाता है।

संयोजन वर्णों को अनदेखा करने वाली खोजें नियमित खोजों की तुलना में धीमी होती हैं।

## नियमित अभिव्यक्तियाँ

Anki 2.1.24+, AnkiMobile 2.0.60+ और AnkiDroid 2.17+ "नियमित अभिव्यक्तियों" के साथ नोट्स में खोज का समर्थन करते हैं, जो पाठ में खोज करने का एक मानक और शक्तिशाली तरीका है।

नियमित अभिव्यक्तियों का उपयोग करके खोजने के लिए `re:` के साथ एक खोज शुरू करें। चीजों को आसान बनाने के लिए, Anki निम्नलिखित को [कच्चे इनपुट](#raw-input) के रूप में मानेगा, इसलिए वहां सूचीबद्ध नियमों को ध्यान में रखें।

कुछ उदाहरण:

`"re:(some|another).*thing"`
उन नोट्स को ढूंढता है जिनमें "some" या "another" है, उसके बाद 0 या अधिक वर्ण हैं, और फिर "thing" है।

`re:\d{3}`
उन नोट्स को ढूंढता है जिनमें एक पंक्ति में 3 अंक हैं।

नियमित अभिव्यक्तियों को एक विशिष्ट फ़ील्ड तक भी सीमित किया जा सकता है। कृपया ध्यान दें कि एक विशिष्ट फ़ील्ड में सामान्य खोजों के विपरीत, फ़ील्ड में नियमित अभिव्यक्तियों को एक सटीक मिलान की आवश्यकता नहीं होती है:

`front:re:[a-c]1`
बड़े या छोटे a1, B1 या c1 से मेल खाता है जो "फ्रंट" फ़ील्ड में कहीं भी होता है।

`front:re:^[a-c]1$`
पिछले उदाहरण के समान, लेकिन यदि a1/b1/c1 से पहले या बाद में कोई अन्य पाठ आता है तो मेल नहीं खाएगा।

Anki 2.1.50+ टैग के लिए नियमित अभिव्यक्तियों का समर्थन करता है:

`tag:re:^parent$`
"parent::child" जैसे किसी भी बाल टैग की परवाह किए बिना, सटीक टैग "parent" वाले नोट्स ढूंढता है।

`"tag:re:lesson-(1[7-9]|2[0-5])"`
"lesson-17" से "lesson-25" तक के टैग वाले नोट्स ढूंढता है।

नियमित अभिव्यक्तियों के बारे में अधिक जानकारी के लिए, [यह वेबसाइट](<https://regexone.com/lesson/introduction_abcs>) देखें।

कुछ बातों से अवगत होना:

- खोज डिफ़ॉल्ट रूप से केस-असंवेदनशील होती है; केस संवेदनशीलता चालू करने के लिए शुरुआत में `(?-i)` का उपयोग करें।
- कुछ पाठ जैसे रिक्त स्थान और नई लाइनें HTML में अलग-अलग रूप से प्रस्तुत की जा सकती हैं - अंतर्निहित HTML सामग्री को देखने के लिए आप संपादन स्क्रीन में HTML संपादक का उपयोग कर सकते हैं।
- Anki के रेगेक्स समर्थन की बारीकियों के लिए, [रेगेक्स क्रेट दस्तावेज़ीकरण](<https://docs.rs/regex/1.3.9/regex/#syntax>) देखें।

## कार्ड की स्थिति

`is:due`
समीक्षा कार्ड और सीखने वाले कार्ड अध्ययन के लिए प्रतीक्षा कर रहे हैं।

`is:new`
नए कार्ड।

`is:learn`
सीखने में कार्ड।

`is:review`
समीक्षाएं (देय और देय नहीं दोनों) और चूके हुए कार्ड।

`is:suspended`
[स्वचालित रूप से](leeches.md) या मैन्युअल रूप से निलंबित किए गए कार्ड।

`is:buried`
[स्वचालित रूप से](studying.md#siblings-and-burying) या मैन्युअल रूप से दफन किए गए कार्ड।

`is:buried-sibling`
स्वचालित रूप से दफन किए गए कार्ड।

`is:buried-manually`
मैन्युअल रूप से दफन किए गए कार्ड।

जो कार्ड [चूक गए](deck-options.md#lapses) हैं वे पिछली कई श्रेणियों में आते हैं, इसलिए अधिक सटीक परिणाम प्राप्त करने के लिए विभिन्न खोज शब्दों को संयोजित करना उपयोगी हो सकता है:

`is:learn is:review`
जो कार्ड चूक गए हैं और फिर से सीखने की प्रतीक्षा कर रहे हैं।

`-is:learn is:review`
समीक्षा कार्ड, चूके हुए कार्ड सहित नहीं।

`is:learn -is:review`
जो कार्ड पहली बार सीखने में हैं।

## झंडे

`flag:0`
बिना झंडे वाले कार्ड।

`flag:1`
लाल झंडे वाले कार्ड।

`flag:2`
नारंगी झंडे वाले कार्ड।

`flag:3`
हरे झंडे वाले कार्ड।

`flag:4`
नीले झंडे वाले कार्ड।

`flag:5`
गुलाबी झंडे वाले कार्ड।

`flag:6`
फ़िरोज़ा झंडे वाले कार्ड।

`flag:7`
बैंगनी झंडे वाले कार्ड।

## कार्ड गुण

`prop:ivl>=10`
10 दिन या उससे अधिक के अंतराल वाले कार्ड।

`prop:due=1`
कल देय कार्ड।

`prop:due=-1`
कल देय कार्ड जिनका अभी तक उत्तर नहीं दिया गया है।

`prop:due>=1`
भविष्य में देय सभी कार्ड, कल सहित।

`prop:due<=-1`
सभी अतिदेय कार्ड।

`prop:due>=-1 prop:due<=1`
कल, आज और कल देय कार्ड।

`prop:reps<10`
10 से कम बार उत्तर दिए गए कार्ड।

`prop:lapses>3`
3 से अधिक बार चूके हुए कार्ड।

`prop:ease!=2.5`
डिफ़ॉल्ट आसानी से आसान या कठिन कार्ड।

`prop:pos<=100`
कतार में 100 से कम या बराबर स्थिति वाले नए कार्ड।

निम्नलिखित खोजों के लिए Anki 23.10+ और FSRS सक्षम होना आवश्यक है:

`prop:s>21`
21 दिनों से अधिक की स्थिरता वाले कार्ड।

`prop:d>0.3`
0.3 से अधिक की कठिनाई वाले कार्ड।

`prop:r<0.9`
0.9 से कम की पुनर्प्राप्ति वाले कार्ड।

## हाल की घटनाएँ

### जोड़ा गया

`added:1`
आज जोड़े गए कार्ड।

`added:7`
पिछले 7 दिनों में जोड़े गए कार्ड।

जांच कार्ड निर्माण समय के बजाय नोट निर्माण समय के विरुद्ध की जाती है, इसलिए समय सीमा के भीतर उत्पन्न किए गए कार्ड शामिल किए जाएंगे, भले ही उनके नोट्स बहुत पहले जोड़े गए हों।

### संपादित

`edited:n`
पिछले n दिनों में नोट टेक्स्ट जोड़े/संपादित किए गए कार्ड।

इसके लिए Anki 2.1.28+ या AnkiMobile 2.0.64+ की आवश्यकता है।

### उत्तर दिया गया

`rated:1`
आज उत्तर दिए गए कार्ड।

`rated:1:2`
आज कठिन (2) उत्तर दिए गए कार्ड।

`rated:7:1`
पिछले 7 दिनों में फिर से (1) उत्तर दिए गए कार्ड।

`rated:31:4`
पिछले 31 दिनों में आसान (4) उत्तर दिए गए कार्ड।

Anki 2.1.39+ 31 दिनों से अधिक की रेटिंग खोजों का समर्थन करता है।

ध्यान दें कि, किसी विशेष दिन उत्तर दिए गए कार्डों को खोजने के लिए, `rated:n -rated:(n-1)` हर बार काम नहीं कर सकता है। इसके बजाय निम्नलिखित का उपयोग करें:

`prop:rated=0`
आज उत्तर दिए गए कार्ड।

`prop:rated=-1`
एक दिन पहले उत्तर दिए गए कार्ड।

`prop:rated=-7`
7 दिन पहले उत्तर दिए गए कार्ड।

### पहली बार उत्तर दिया गया

Anki 2.1.45+ की आवश्यकता है।

`introduced:1`
आज पहली बार उत्तर दिए गए कार्ड।

`introduced:365`
पिछले 365 दिनों के भीतर पहली बार उत्तर दिए गए कार्ड।

## विशेष वर्णों का मिलान

यदि आप Anki 2.1.36 से पहले के संस्करण का उपयोग कर रहे हैं तो निम्नलिखित खोजें काम नहीं कर सकती हैं।

जैसा कि पिछले अनुभाग में दिखाया गया है, कुछ वर्ण जैसे `*`, `_` और `"` का खोज में एक विशेष अर्थ होता है। यदि आपको खोज में उन वर्णों का पता लगाने की आवश्यकता है, तो आपको Anki को बताना होगा कि उन्हें विशेष रूप से न मानें। इसे "एक वर्ण को एस्केप करना" कहा जाता है और यह मुख्य रूप से दोहरे उद्धरण और बैकस्लैश का उपयोग करके किया जाता है।

- _स्पेस_\
  रिक्त स्थान वाले किसी चीज़ का मिलान करने के लिए, `"पूरे पद"` को दोहरे उद्धरणों में संलग्न करें। यदि यह एक कोलन खोज है, तो आपके पास केवल `पद:"कोलन के बाद"` को उद्धृत करने का विकल्प भी है।

- `And`/`Or`\
  इन शब्दों को खोजने के लिए, उन्हें दोहरे उद्धरणों में लपेटें। उदाहरण के लिए, `dog "and" cat` "dog", "cat" और "and" शब्द की खोज करता है। यदि आप पिछले उदाहरण की तरह पूरे खोज पद को उद्धरणों से लपेटते हैं, तो आपको `and` या `or` को एस्केप करने की आवश्यकता नहीं है।

- `"` , `*` और `_`\
  इन वर्णों को शाब्दिक रूप से मानने के लिए उनके पहले एक बैकस्लैश जोड़ें। उदाहरण के लिए, `_` किसी भी एकल वर्ण से मेल खाएगा, लेकिन `\_` केवल एक वास्तविक अंडरस्कोर से मेल खाता है।

- `\`\
  चूंकि एक बैकस्लैश का उपयोग अन्य वर्णों से विशेष अर्थ हटाने के लिए किया जाता है, इसलिए इसे भी विशेष रूप से माना जाता है। यदि आपको एक वास्तविक बैकस्लैश खोजने की आवश्यकता है, तो `\` के बजाय `\\` का उपयोग करें।

- `(` और `)`\
  आप पूरे पद को उद्धरणों में संलग्न करके, एक बैकस्लैश का उपयोग करके, या दोनों को एक ही समय में कोष्ठक के लिए खोज सकते हैं। उदाहरण के लिए, `"(text)"`, `\(text\)` और `"\(text\)"` सभी समतुल्य खोजें हैं, और `(text)` की खोज करते हैं।

- `-`\
  `-` से एक खोज पद शुरू करना आमतौर पर इसे उलट देता है: `-dog` उदाहरण के लिए कुत्ते को छोड़कर सब कुछ से मेल खाता है। यदि आप इसके बजाय एक वास्तविक हाइफ़न शामिल करना चाहते हैं, तो आप या तो एक बैकस्लैश का उपयोग कर सकते हैं, या पाठ को उद्धरणों में शामिल कर सकते हैं। उदाहरण के लिए, `\-free` या `"-free"` "guilt-free" और "cruelty-free" से मेल खाएगा।

- `:`\
  कोलन को बैकस्लैश का उपयोग करके एस्केप किया जाना चाहिए जब तक कि वे किसी अन्य, अनएस्केप्ड कोलन से पहले न हों। उदाहरण के लिए, `w:3:30` शब्द सीमा पर "3:30" की खोज करता है और आपको बैकस्लैश का उपयोग करने की आवश्यकता नहीं है। हालाँकि, यदि आप एक कोलन खोज का उपयोग नहीं करते हैं, तो कोलन को इस तरह से एस्केप करने की आवश्यकता है: `3\:30`।

- `&`, `<`, और `>`\
  Anki में खोज करते समय `&`, `<`, और `>` को HTML के रूप में माना जाता है, और इस तरह, उन्हें युक्त खोजें अपेक्षा के अनुरूप काम नहीं करती हैं। हालाँकि, आप उनके संबंधित HTML इकाई नामों (`&amp;` के लिए `&`, `&lt;` के लिए `<`, और `&gt;` के लिए `>`) का उपयोग करके उन्हें खोज सकते हैं। उदाहरण के लिए, `&amp;text` की खोज करने से एक फ़ील्ड में `&text` वाले एक नोट की खोज होती है।

### कच्चा इनपुट

कुछ कीवर्ड (जैसे `re:`) से पहले आने वाले पाठ को कच्चे इनपुट के रूप में माना जाएगा। यानी, ऊपर सूचीबद्ध वर्ण काफी हद तक अपना विशेष अर्थ खो देते हैं। ऐसे संदर्भ में, अस्पष्टता को रोकने के लिए केवल न्यूनतम एस्केपिंग की आवश्यकता होती है:

- दोहरे उद्धरण (`"`) को एस्केप किया जाना चाहिए।

- रिक्त स्थान और अनएस्केप्ड कोष्ठक के लिए खोज पद को उद्धृत करने की आवश्यकता होती है।

- खोज पद एक विषम संख्या में बैकस्लैश के साथ समाप्त नहीं होना चाहिए।

## ऑब्जेक्ट आईडी

`nid:123`
नोट आईडी 123 वाला नोट।

`cid:123,456,789`
कार्ड आईडी 123, 456, या 789 वाले सभी कार्ड।

नोट और कार्ड आईडी ब्राउज़र में [कार्ड जानकारी](stats.md) संवाद में पाए जा सकते हैं। ये खोजें ऐड-ऑन विकास करते समय या अन्यथा डेटाबेस के साथ मिलकर काम करते समय भी सहायक हो सकती हैं।

## कस्टम डेटा

Anki कार्ड पर छोटी मात्रा में कस्टम डेटा संग्रहीत करने की अनुमति देता है, जिससे कस्टम शेड्यूलर जैसे उन्नत उपयोग के मामले सक्षम होते हैं। इस सुविधा के उल्लेखनीय अनुप्रयोगों में से एक FSRS के पहले के कार्यान्वयन में था। Anki 23.10+ में, इसे खोजने के कुछ तरीके हैं:

`has-cd:v`
कस्टम डेटा में `v` गुण वाले कार्ड।

`prop:cdn:d>5`
कस्टम डेटा में `d` के मान (आमतौर पर FSRS में कठिनाई को संदर्भित करता है) 5 से अधिक वाले कार्ड।

`prop:cds:v=reschedule`
कस्टम डेटा में स्ट्रिंग `v` के बराबर `reschedule` वाले कार्ड।

## अन्य खोजें

`prop:due=1 is:learn`
कल के लिए देय इंटरडे लर्निंग कार्ड।

`prop:due=0 is:learn -introduced:1`
आज के लिए देय इंटरडे लर्निंग कार्ड।

`prop:resched=0`
आज पुनर्निर्धारित किए गए कार्ड, या तो **देय तिथि निर्धारित करें** या **परिवर्तन पर कार्ड पुनर्निर्धारित करें** का उपयोग करके।