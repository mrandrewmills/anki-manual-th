# অনুসন্ধান

<!-- toc -->

আঙ্কির ব্রাউজ স্ক্রিন এবং ফিল্টার করা ডেক বৈশিষ্ট্যটি নির্দিষ্ট কার্ড/নোট অনুসন্ধানের জন্য একটি সাধারণ পদ্ধতি ব্যবহার করে। এই পদ্ধতিটি FSRS অপ্টিমাইজেশনের সুযোগ সামঞ্জস্য করতেও ব্যবহার করা যেতে পারে।

## সাধারণ অনুসন্ধান

আপনি যখন অনুসন্ধান বাক্সে কিছু টেক্সট টাইপ করেন, তখন আঙ্কি মিলে যাওয়া নোটগুলি খুঁজে পায়
এবং তাদের কার্ডগুলি প্রদর্শন করে। আঙ্কি নোটগুলির সমস্ত ক্ষেত্রে অনুসন্ধান করে, তবে
ট্যাগগুলির জন্য অনুসন্ধান করে না (ট্যাগগুলির জন্য অনুসন্ধান করতে [এই বিভাগের পরে](#tags-decks-cards-and-notes) দেখুন)। কিছু উদাহরণ:

`dog`
"dog" এর জন্য অনুসন্ধান করে - "doggy" এবং "underdog" এর মতো শব্দগুলির সাথেও মিলবে।

`dog cat`
"dog" এবং "cat" উভয়ই আছে এমন নোটগুলি খুঁজে পায়, যেমন "raining cats and dogs"।

`dog or cat`
"dog" বা "cat" আছে এমন নোটগুলি খুঁজে পায়।

`dog (cat or mouse)`
"dog" এবং "cat" আছে এমন নোটগুলি খুঁজে পায়, অথবা "dog" এবং "mouse" আছে এমন নোটগুলি খুঁজে পায়।

`-cat`
"cat" নেই এমন নোটগুলি খুঁজে পায়।

`-cat -mouse`
"cat" বা "mouse" নেই এমন নোটগুলি খুঁজে পায়।

`-(cat or mouse)`
উপরের মতো একই।

`"a dog"`
"a dog" এর সঠিক অক্ষর ক্রম আছে এমন নোটগুলি খুঁজে পায়, যেমন "atta dog", কিন্তু "dog a" বা "adog" নয়।

`-"a dog"`
"a dog" এর সঠিক অক্ষর ক্রম নেই এমন নোটগুলি খুঁজে পায়।

`d_g`
d, <এক অক্ষর>, g আছে এমন নোটগুলি খুঁজে পায়, যেমন dog, dig, dug, ইত্যাদি।

`d*g`
d, <শূন্য বা একাধিক অক্ষর>, g আছে এমন নোটগুলি খুঁজে পায়, যেমন dg, dog, dung, ইত্যাদি।

`w:dog`
অক্ষর ক্রমের পরিবর্তে "dog" শব্দটির জন্য অনুসন্ধান করে - "dog" এর সাথে মিলবে, কিন্তু "doggy" বা "underdog" এর সাথে নয়। আঙ্কি 2.1.24+, আঙ্কি মোবাইল 2.1.61+, বা আঙ্কিড্রয়েড 2.17+ প্রয়োজন। মনে রাখবেন যে ফরম্যাটিং পরিবর্তনগুলি শব্দ সীমানা হিসাবে ব্যাখ্যা করা হতে পারে, যেমন `w:exam` এর জন্য অনুসন্ধান করলে **example** এর সাথে মিলবে, কারণ example এর "exam" অংশটি বোল্ড ফরম্যাটে আছে।

`w:dog*`
"dog" এবং "doggy" এর সাথে মিলবে, কিন্তু "underdog" এর সাথে নয়।

`w:*dog`
"dog" এবং "underdog" এর সাথে মিলবে, কিন্তু "doggy" এর সাথে নয়।

উপরের থেকে কিছু বিষয় লক্ষ্যণীয়:

- অনুসন্ধান পদগুলি স্পেস দ্বারা পৃথক করা হয়।

- যখন একাধিক অনুসন্ধান পদ সরবরাহ করা হয়, আঙ্কি এমন নোটগুলি খুঁজে পায় যা
  সমস্ত পদের সাথে মেলে - প্রতিটি পদের মধ্যে একটি অন্তর্নিহিত `and`
  সন্নিবেশ করা হয়। আঙ্কি 2.1.24+, আঙ্কি মোবাইল 2.0.60+, এবং আঙ্কিড্রয়েড 2.17+ এ আপনি
  যদি চান তবে সুনির্দিষ্ট হতে পারেন (`dog and cat` হল `dog cat` এর মতোই), তবে আঙ্কির পুরানো সংস্করণগুলি `and` কে অনুসন্ধানের জন্য আরও একটি শব্দ হিসাবে বিবেচনা করবে।

- আপনি `or` ব্যবহার করতে পারেন যদি আপনার কেবল একটি পদের সাথে মিল প্রয়োজন হয়।

- আপনি একটি পদকে মাইনাস চিহ্ন (`-`) দিয়ে উপসর্গ হিসাবে ব্যবহার করতে পারেন যাতে সেই
  পদের সাথে মেলে না এমন নোটগুলি খুঁজে পাওয়া যায়।

- আপনি অনুসন্ধান পদগুলি বন্ধনীতে রেখে গোষ্ঠীভুক্ত করতে পারেন, যেমন
  `dog (cat or mouse)` উদাহরণে। OR এবং AND অনুসন্ধানগুলি একত্রিত করার সময় এটি গুরুত্বপূর্ণ হয়ে ওঠে - উদাহরণে, বন্ধনী সহ, এটি "dog cat" বা "dog mouse" এর সাথে মেলে, যখন সেগুলি ছাড়া এটি "dog and cat" বা "mouse" এর সাথে মিলবে।

- আঙ্কি কেবলমাত্র আপনার কনফিগার করা [সাজানোর ক্ষেত্রে](editing.md#customizing-fields) ফরম্যাটিংয়ের মধ্যে অনুসন্ধান করতে সক্ষম। উদাহরণস্বরূপ, যদি আপনি আপনার একটি ক্ষেত্রে "**exa**mple" যোগ করেন, "exa" অংশটি বোল্ড ফরম্যাটে, তাহলে `example` এর জন্য অনুসন্ধান করার সময় এটি মিলবে না যদি না সেই ক্ষেত্রটি সাজানোর ক্ষেত্র হয়। যদি একটি শব্দ ফরম্যাট করা না হয়, অথবা ফরম্যাটিং শব্দের মাঝখানে পরিবর্তন না হয়, তাহলে আঙ্কি এটি যেকোনো ক্ষেত্রে খুঁজে পেতে সক্ষম হবে।

- স্ট্যান্ডার্ড অনুসন্ধানগুলি ল্যাটিন অক্ষরগুলির জন্য কেস ইনসেনসিটিভ - a-z A-Z এর সাথে মিলবে, এবং এর বিপরীত। সিরিলিকের মতো অন্যান্য অক্ষরগুলি একটি স্ট্যান্ডার্ড অনুসন্ধানে কেস সেনসিটিভ, তবে শব্দ সীমানা বা রেগুলার এক্সপ্রেশন (`w:`, `re:`) এর উপর অনুসন্ধান করে কেস ইনসেনসিটিভ করা যেতে পারে।

## একটি ক্ষেত্রের মধ্যে সীমাবদ্ধ করা

আপনি আঙ্কিকে একটি নির্দিষ্ট ক্ষেত্র কিছু টেক্সট ধারণ করলে তবেই মেলাতে বলতে পারেন।
পূর্ববর্তী অনুসন্ধান উদাহরণগুলির বিপরীতে, ক্ষেত্রগুলিতে অনুসন্ধান ডিফল্টরূপে একটি সঠিক মিলের প্রয়োজন।

`front:dog`
"dog" এর সাথে হুবহু মিলে যাওয়া ফ্রন্ট ক্ষেত্র সহ নোটগুলি খুঁজে পায়। "a dog" লেখা একটি ক্ষেত্র মিলবে না।

`"animal front:a dog"`
"Animal Front" ক্ষেত্রটি হুবহু "a dog" এমন নোটগুলি খুঁজে পায়। ডাবল কোট বাধ্যতামূলক:
[এই বিভাগের পরে](#matching-special-characters) বিশেষ অক্ষর মেলানো দেখুন।

`front:dog*`
"Front" ক্ষেত্রটিতে কোথাও "dog" আছে এমন নোটগুলি খুঁজে পায়।

`front:`
একটি খালি ফ্রন্ট ক্ষেত্র আছে এমন নোটগুলি খুঁজে পায়।

`front:_*
একটি অ-খালি ফ্রন্ট ক্ষেত্র আছে এমন নোটগুলি খুঁজে পায়।

`front:*
একটি ফ্রন্ট ক্ষেত্র আছে এমন নোটগুলি খুঁজে পায়, খালি হোক বা না হোক।

`fr*:text`
"fr" দিয়ে শুরু হওয়া একটি ক্ষেত্রে নোটগুলি খুঁজে পায়। আঙ্কি 2.1.24+, আঙ্কি মোবাইল 2.1.60+, বা আঙ্কিড্রয়েড 2.17+ প্রয়োজন।

## ট্যাগ, ডেক, কার্ড এবং নোট

`tag:animal`
"animal" ট্যাগ সহ নোটগুলি খুঁজে পায়, অথবা "animal::mammal" এর মতো সাবট্যাগগুলিও।

`tag:none`
কোনো ট্যাগ নেই এমন নোটগুলি খুঁজে পায়।

`tag:ani*`
"ani" দিয়ে শুরু হওয়া ট্যাগ সহ নোটগুলি খুঁজে পায়।

`deck:french`
"French" নামক একটি শীর্ষ-স্তরের ডেকে কার্ডগুলি খুঁজে পায়, অথবা "French::Words" এর মতো এর সাবডেকগুলিতে। এটি সেই নামের সাবডেকগুলির সাথে মিলবে না, যেমন "Languages::French"।

`deck:french::words`
"French::Words" সাবডেকে কার্ডগুলি খুঁজে পায়।

`deck:french -deck:french::*`
"French" এ কার্ডগুলি খুঁজে পায়, তবে এর সাবডেকগুলিতে নয়।

`deck:"french words"`
ডেকের নামে স্পেস থাকলে অনুসন্ধান।

`"deck:french words"`
আগের মতো একই।

`deck:filtered`
শুধুমাত্র ফিল্টার করা ডেক।

`-deck:filtered`
শুধুমাত্র সাধারণ ডেক।

`preset:"Default"`
"Default" ডেক অপশন প্রিসেট ব্যবহার করে এমন সমস্ত ডেকের কার্ড।
আঙ্কি 23.10+, আঙ্কি মোবাইল 23.10+ বা আঙ্কিড্রয়েড 2.17+ প্রয়োজন।

`card:forward`
"Forward" নামক একটি কার্ডের ধরন দ্বারা তৈরি কার্ডগুলি খুঁজে পায়।

`card:1`
কার্ডের ধরন নম্বর দ্বারা কার্ড অনুসন্ধান করে, যেমন একটি নোটের দ্বিতীয় ক্লোজ
ডিলিশন খুঁজে পেতে, আপনি `card:2` ব্যবহার করবেন।

`note:basic`
"Basic" নামক একটি নোটের ধরন দিয়ে তৈরি কার্ডগুলি অনুসন্ধান করে।

## অ্যাক্সেন্ট/কম্বাইনিং অক্ষর উপেক্ষা করা

আঙ্কি 2.1.24+, আঙ্কি মোবাইল 2.0.60+ বা আঙ্কিড্রয়েড 2.17+ প্রয়োজন।

আপনি `nc:` ("নো কম্বাইনিং" এর জন্য) ব্যবহার করে আঙ্কিকে কম্বাইনিং অক্ষরগুলি উপেক্ষা করতে বলতে পারেন। উদাহরণস্বরূপ:

`nc:uber`
"uber", "über", "Über" ইত্যাদিসহ নোটগুলির সাথে মিলে যায়।

`nc:は`
"は", "ば", এবং "ぱ" এর সাথে মিলে যায়।

কম্বাইনিং অক্ষর উপেক্ষা করা অনুসন্ধানগুলি নিয়মিত অনুসন্ধানগুলির চেয়ে ধীর।

## রেগুলার এক্সপ্রেশন

আঙ্কি 2.1.24+, আঙ্কি মোবাইল 2.0.60+ এবং আঙ্কিড্রয়েড 2.17+ "রেগুলার এক্সপ্রেশন" সহ নোটগুলিতে অনুসন্ধান সমর্থন করে,
টেক্সটে অনুসন্ধানের একটি মানক এবং শক্তিশালী উপায়।

রেগুলার এক্সপ্রেশন ব্যবহার করে অনুসন্ধান করতে `re:` দিয়ে একটি অনুসন্ধান শুরু করুন। জিনিসগুলি সহজ করার জন্য, আঙ্কি নিম্নলিখিতগুলিকে [কাঁচা ইনপুট](#raw-input) হিসাবে বিবেচনা করবে, তাই সেখানে তালিকাভুক্ত নিয়মগুলি মনে রাখবেন।

কিছু উদাহরণ:

`"re:(some|another).*thing"`
"some" বা "another" আছে এমন নোটগুলি খুঁজে পায়, তারপরে 0 বা তার বেশি অক্ষর, এবং তারপরে "thing"।

`re:\d{3}`
টানা 3টি অঙ্ক আছে এমন নোটগুলি খুঁজে পায়।

রেগুলার এক্সপ্রেশনগুলি একটি নির্দিষ্ট ক্ষেত্রেও সীমাবদ্ধ করা যেতে পারে। দয়া করে মনে রাখবেন যে একটি নির্দিষ্ট ক্ষেত্রে সাধারণ অনুসন্ধানগুলির বিপরীতে, ক্ষেত্রগুলিতে রেগুলার এক্সপ্রেশনগুলির একটি সঠিক মিলের প্রয়োজন হয় না:

`front:re:[a-c]1`
"ফ্রন্ট" ক্ষেত্রে কোথাও উপস্থিত আপারকেস বা লোয়ারকেস a1, B1 বা c1 এর সাথে মিলে যায়।

`front:re:^[a-c]1$`
পূর্ববর্তী উদাহরণের মতো একই, তবে a1/b1/c1 এর আগে বা পরে অন্য কোনো টেক্সট থাকলে মিলবে না।

আঙ্কি 2.1.50+ ট্যাগগুলির জন্য রেগুলার এক্সপ্রেশন সমর্থন করে:

`tag:re:^parent$`
"parent" এর মতো সঠিক ট্যাগ সহ নোটগুলি খুঁজে পায়, "parent::child" এর মতো কোনো চাইল্ড ট্যাগ উপেক্ষা করে।

`"tag:re:lesson-(1[7-9]|2[0-5])"`
"lesson-17" থেকে "lesson-25" ট্যাগ সহ নোটগুলি খুঁজে পায়।

রেগুলার এক্সপ্রেশন সম্পর্কে আরও তথ্যের জন্য, [এই ওয়েবসাইট](<https://regexone.com/lesson/introduction_abcs>) দেখুন।

কিছু বিষয় সম্পর্কে সচেতন থাকতে হবে:

- অনুসন্ধান ডিফল্টরূপে কেস-ইনসেনসিটিভ; কেস সেনসিটিভিটি চালু করতে শুরুতে `(?-i)` ব্যবহার করুন।
- স্পেস এবং নিউলাইনের মতো কিছু টেক্সট HTML এ ভিন্নভাবে উপস্থাপন করা যেতে পারে - আপনি অন্তর্নিহিত HTML বিষয়বস্তু দেখতে সম্পাদনা স্ক্রিনে HTML সম্পাদক ব্যবহার করতে পারেন।
- আঙ্কির রেগুলার এক্সপ্রেশন সমর্থনের নির্দিষ্টকরণের জন্য, [regex ক্র্যাট ডকুমেন্টেশন](<https://docs.rs/regex/1.3.9/regex/#syntax>) দেখুন।

## কার্ডের অবস্থা

`is:due`
পর্যালোচনা কার্ড এবং শেখার কার্ডগুলি অধ্যয়নের অপেক্ষায় রয়েছে।

`is:new`
নতুন কার্ড।

`is:learn`
শেখার মধ্যে থাকা কার্ড।

`is:review`
পর্যালোচনা (বকেয়া এবং অ-বকেয়া উভয়ই) এবং ল্যাপস করা কার্ড।

`is:suspended`
[স্বয়ংক্রিয়ভাবে](leeches.md) বা ম্যানুয়ালি স্থগিত করা কার্ড।

`is:buried`
[স্বয়ংক্রিয়ভাবে](studying.md#siblings-and-burying) বা ম্যানুয়ালি চাপা দেওয়া কার্ড।

`is:buried-sibling`
স্বয়ংক্রিয়ভাবে চাপা দেওয়া কার্ড।

`is:buried-manually`
ম্যানুয়ালি চাপা দেওয়া কার্ড।

যে কার্ডগুলি [ল্যাপস](deck-options.md#lapses) হয়েছে সেগুলি পূর্ববর্তী কয়েকটি বিভাগে পড়ে, তাই আরও সুনির্দিষ্ট ফলাফল পেতে বিভিন্ন অনুসন্ধান পদ একত্রিত করা সহায়ক হতে পারে:

`is:learn is:review`
ল্যাপস হয়েছে এবং পুনরায় শেখার অপেক্ষায় থাকা কার্ড।

`-is:learn is:review`
পর্যালোচনা কার্ড, ল্যাপস করা কার্ড অন্তর্ভুক্ত নয়।

`is:learn -is:review`
প্রথমবারের মতো শেখার মধ্যে থাকা কার্ড।

## পতাকা

`flag:0`
কোনো পতাকা নেই এমন কার্ড।

`flag:1`
লাল পতাকা সহ কার্ড।

`flag:2`
কমলা পতাকা সহ কার্ড।

`flag:3`
সবুজ পতাকা সহ কার্ড।

`flag:4`
নীল পতাকা সহ কার্ড।

`flag:5`
গোলাপি পতাকা সহ কার্ড।

`flag:6`
ফিরোজা পতাকা সহ কার্ড।

`flag:7`
বেগুনি পতাকা সহ কার্ড।

## কার্ডের বৈশিষ্ট্য

`prop:ivl>=10`
10 দিন বা তার বেশি ব্যবধান সহ কার্ড।

`prop:due=1`
আগামীকাল বকেয়া কার্ড।

`prop:due=-1`
গতকাল বকেয়া কার্ড যা এখনও উত্তর দেওয়া হয়নি।

`prop:due>=1`
ভবিষ্যতে বকেয়া সমস্ত কার্ড, আগামীকাল সহ।

`prop:due<=-1`
সমস্ত বকেয়া কার্ড।

`prop:due>=-1 prop:due<=1`
গতকাল, আজ এবং আগামীকাল বকেয়া কার্ড।

`prop:reps<10`
10 বারের কম উত্তর দেওয়া কার্ড।

`prop:lapses>3`
3 বারের বেশি ল্যাপস করা কার্ড।

`prop:ease!=2.5`
ডিফল্ট সহজতার চেয়ে সহজ বা কঠিন কার্ড।

`prop:pos<=100`
সারিটিতে 100 বা তার কম অবস্থানে নতুন কার্ড।

নিম্নলিখিত অনুসন্ধানগুলির জন্য আঙ্কি 23.10+ এবং FSRS সক্ষম করা প্রয়োজন:

`prop:s>21`
21 দিনের বেশি স্থিতিশীলতা সহ কার্ড।

`prop:d>0.3`
0.3 এর বেশি কঠিনতা সহ কার্ড।

`prop:r<0.9`
0.9 এর কম পুনরুদ্ধারযোগ্যতা সহ কার্ড।

## সাম্প্রতিক ঘটনা

### যোগ করা হয়েছে

`added:1`
আজ যোগ করা কার্ড।

`added:7`
গত 7 দিনে যোগ করা কার্ড।

নোট তৈরির সময়ের পরিবর্তে কার্ড তৈরির সময়ের বিরুদ্ধে চেক করা হয়, তাই সময়সীমার মধ্যে তৈরি করা কার্ডগুলি অন্তর্ভুক্ত করা হবে এমনকি যদি তাদের নোটগুলি অনেক আগে যোগ করা হয়ে থাকে।

### সম্পাদিত

`edited:n`
গত n দিনে নোটের টেক্সট যোগ/সম্পাদনা করা কার্ড।

আঙ্কি 2.1.28+ বা আঙ্কি মোবাইল 2.0.64+ প্রয়োজন।

### উত্তর দেওয়া হয়েছে

`rated:1`
আজ উত্তর দেওয়া কার্ড।

`rated:1:2`
আজ হার্ড (2) উত্তর দেওয়া কার্ড।

`rated:7:1`
গত 7 দিনে আবার (1) উত্তর দেওয়া কার্ড।

`rated:31:4`
গত 31 দিনে সহজ (4) উত্তর দেওয়া কার্ড।

আঙ্কি 2.1.39+ 31 দিনের বেশি রেটিং অনুসন্ধান সমর্থন করে।

মনে রাখবেন যে, একটি নির্দিষ্ট দিনে উত্তর দেওয়া কার্ডগুলি অনুসন্ধান করতে,
`rated:n -rated:(n-1)` প্রতিবার কাজ নাও করতে পারে। এর পরিবর্তে নিম্নলিখিতটি ব্যবহার করুন:

`prop:rated=0`
আজ উত্তর দেওয়া কার্ড।

`prop:rated=-1`
এক দিন আগে উত্তর দেওয়া কার্ড।

`prop:rated=-7`
7 দিন আগে উত্তর দেওয়া কার্ড।

### প্রথম উত্তর দেওয়া হয়েছে

আঙ্কি 2.1.45+ প্রয়োজন।

`introduced:1`
আজ প্রথমবারের মতো উত্তর দেওয়া কার্ড।

`introduced:365`
গত 365 দিনের মধ্যে প্রথমবারের মতো উত্তর দেওয়া কার্ড।

## বিশেষ অক্ষর মেলানো

আপনি যদি আঙ্কি 2.1.36 এর আগের সংস্করণ ব্যবহার করেন তবে নিম্নলিখিত অনুসন্ধানগুলি কাজ নাও করতে পারে।

পূর্ববর্তী বিভাগে দেখানো হয়েছে, `*`, `_` এবং `"` এর মতো কিছু অক্ষরের অনুসন্ধানে একটি বিশেষ অর্থ রয়েছে। যদি আপনাকে অনুসন্ধানে সেই অক্ষরগুলি খুঁজে বের করতে হয়, তাহলে আপনাকে আঙ্কিকে বলতে হবে যে সেগুলিকে বিশেষ হিসাবে বিবেচনা না করতে। এটিকে "একটি অক্ষর এস্কেপ করা" বলা হয় এবং এটি প্রাথমিকভাবে ডাবল কোট এবং ব্যাকস্ল্যাশ ব্যবহার করে করা হয়।

-   _স্পেস_
    স্পেস সহ কিছু মেলাতে, `"পুরো পদটিকে"` ডাবল কোটের মধ্যে আবদ্ধ করুন। যদি এটি একটি কোলন অনুসন্ধান হয়, তবে আপনার কাছে শুধুমাত্র `part:"colon এর পরে"` উদ্ধৃত করার বিকল্পও রয়েছে।

-   `And`/`Or`
    এই শব্দগুলি অনুসন্ধান করতে, সেগুলিকে ডাবল কোট দিয়ে মোড়ানো করুন। উদাহরণস্বরূপ, `dog "and" cat` "dog", "cat" এবং "and" শব্দটির জন্য অনুসন্ধান করে।
    যদি আপনি পূর্ববর্তী উদাহরণের মতো সম্পূর্ণ অনুসন্ধান পদটি কোট দিয়ে মোড়ানো করেন, তাহলে আপনাকে `and` বা `or` এস্কেপ করার প্রয়োজন নেই।

-   `"`, `*` এবং `_`
    এগুলিকে আক্ষরিকভাবে বিবেচনা করতে এই অক্ষরগুলির আগে একটি ব্যাকস্ল্যাশ যোগ করুন। উদাহরণস্বরূপ,
    `_` যেকোনো একক অক্ষরের সাথে মিলবে, তবে `\_` শুধুমাত্র একটি আসল আন্ডারস্কোরের সাথে মিলবে।

-   `\`
    যেহেতু একটি ব্যাকস্ল্যাশ অন্যান্য অক্ষর থেকে বিশেষ অর্থ সরাতে ব্যবহৃত হয়, এটিও বিশেষ হিসাবে বিবেচিত হয়। যদি আপনাকে একটি আসল ব্যাকস্ল্যাশ অনুসন্ধান করতে হয়, `\` এর পরিবর্তে `\\` ব্যবহার করুন।

-   `(` এবং `)`
    আপনি পুরো পদটি কোট দিয়ে আবদ্ধ করে, একটি ব্যাকস্ল্যাশ ব্যবহার করে, অথবা উভয়ই একই সময়ে ব্যবহার করে বন্ধনী অনুসন্ধান করতে পারেন। উদাহরণস্বরূপ, `"(text)"`, `\(text\)` এবং `"\(text\)"` সবগুলিই সমতুল্য অনুসন্ধান, এবং `(text)` এর জন্য অনুসন্ধান করে।

-   `-`
    একটি অনুসন্ধান পদ `-` দিয়ে শুরু করলে সাধারণত এটি উল্টে যায়: `-dog` উদাহরণস্বরূপ dog ছাড়া সবকিছু মেলায়। আপনি যদি পরিবর্তে একটি আসল হাইফেন অন্তর্ভুক্ত করতে চান, তবে আপনি একটি ব্যাকস্ল্যাশ ব্যবহার করতে পারেন, অথবা টেক্সটটি কোট দিয়ে আবদ্ধ করতে পারেন। উদাহরণস্বরূপ, `\-free` বা `"-free"` "guilt-free" এবং "cruelty-free" এর সাথে মিলবে।

-   `:`
    কোলনগুলিকে ব্যাকস্ল্যাশ ব্যবহার করে এস্কেপ করতে হবে যদি না তাদের আগে অন্য একটি, অ-এস্কেপ করা কোলন থাকে। উদাহরণস্বরূপ, `w:3:30` শব্দ সীমানায় "3:30" এর জন্য অনুসন্ধান করে এবং আপনাকে ব্যাকস্ল্যাশ ব্যবহার করার প্রয়োজন হয় না। তবে, যদি আপনি কোলন অনুসন্ধান ব্যবহার না করেন, তবে কোলনগুলিকে এভাবে এস্কেপ করতে হবে: `3\:30`।

-   `&`, `<`, এবং `>`
    আঙ্কিতে অনুসন্ধান করার সময় `&`, `<`, এবং `>` HTML হিসাবে বিবেচিত হয় এবং এইভাবে, সেগুলি ধারণ করা অনুসন্ধানগুলি প্রত্যাশিতভাবে কাজ করে না। তবে, আপনি তাদের সংশ্লিস্ট HTML সত্তা নামগুলি (`&amp;` এর জন্য `&`, `&lt;` এর জন্য `<`, এবং `&gt;` এর জন্য `>`) ব্যবহার করে অনুসন্ধান করতে পারেন। উদাহরণস্বরূপ, `&amp;text` অনুসন্ধান করলে একটি ক্ষেত্রে `&text` সহ একটি নোট অনুসন্ধান করে।

### কাঁচা ইনপুট

নির্দিষ্ট কীওয়ার্ড দ্বারা পূর্বে থাকা টেক্সট (যেমন `re:`) কাঁচা ইনপুট হিসাবে বিবেচিত হবে। অর্থাৎ, উপরে তালিকাভুক্ত অক্ষরগুলি মূলত তাদের বিশেষ অর্থ হারাবে। এই ধরনের প্রসঙ্গে, শুধুমাত্র অস্পষ্টতা প্রতিরোধ করার জন্য সর্বনিম্ন এস্কেপিং প্রয়োজন:

-   ডাবল কোট (`"`) এস্কেপ করতে হবে।

-   স্পেস এবং অ-এস্কেপ করা বন্ধনীগুলির জন্য অনুসন্ধান পদটিকে কোট করতে হবে।

-   অনুসন্ধান পদটি বিজোড় সংখ্যক ব্যাকস্ল্যাশ দিয়ে শেষ হবে না।

## অবজেক্ট আইডি

`nid:123`
নোট আইডি 123 সহ নোট।

`cid:123,456,789`
কার্ড আইডি 123, 456, বা 789 সহ সমস্ত কার্ড।

নোট এবং কার্ড আইডিগুলি ব্রাউজারে [কার্ড তথ্য](stats.md) ডায়ালগে পাওয়া যাবে। এই অনুসন্ধানগুলি অ্যাড-অন ডেভেলপমেন্ট করার সময় বা অন্যথায় ডেটাবেসের সাথে ঘনিষ্ঠভাবে কাজ করার সময়ও সহায়ক হতে পারে।

## কাস্টম ডেটা

আঙ্কি কার্ডগুলিতে অল্প পরিমাণে কাস্টম ডেটা সংরক্ষণ করার অনুমতি দেয়,
যা কাস্টম শিডিউলারের মতো উন্নত ব্যবহারের ক্ষেত্রে সক্ষম করে। এই বৈশিষ্ট্যের
উল্লেখযোগ্য অ্যাপ্লিকেশনগুলির মধ্যে একটি ছিল FSRS এর পূর্ববর্তী বাস্তবায়নে।
আঙ্কি 23.10+ এ, এটি অনুসন্ধান করার কিছু উপায় রয়েছে:

`has-cd:v`
কাস্টম ডেটাতে `v` বৈশিষ্ট্য সহ কার্ড।

`prop:cdn:d>5`
কাস্টম ডেটাতে `d` এর মান (সাধারণত FSRS এ কঠিনতা বোঝায়) 5 এর বেশি কার্ড।

`prop:cds:v=reschedule`
কাস্টম ডেটাতে `v` স্ট্রিং "reschedule" এর সমান কার্ড।

## অন্যান্য অনুসন্ধান

`prop:due=1 is:learn`
আগামীকালের জন্য বকেয়া আন্তঃদিন শেখার কার্ড।

`prop:due=0 is:learn -introduced:1`
আজকের জন্য বকেয়া আন্তঃদিন শেখার কার্ড।

`prop:resched=0`
আজ পুনরায় সময়সূচী করা কার্ড, হয় **নির্ধারিত তারিখ সেট করুন** বা **পরিবর্তনে কার্ডগুলি পুনরায় সময়সূচী করুন** ব্যবহার করে।